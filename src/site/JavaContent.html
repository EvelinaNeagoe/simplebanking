<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Java Content</title>
</head>
<body>
	<h1>Reminders</h1>
	<hr>
	<div>
	  <b>Java esentials</b>
	    <li>Java classes
	    <li>Java interfaces
	    <li>Inheritance, polymorfism
	    <li>Visibility (private, protected ,etc)
	      - encapsulation
	    <li>Keywords
	   <br>
	   <b>java collection</b>
	     <li>List
	     <li>Set
	     <li>Map
	     <li>Iterators - for each
	   <br>
	   <b>Threading</b>
	   <li>Thread, synchronized, wait, notify
	   <li>Deadlock
	   <li>Thread safety (processor cache)
	   <li>volatile - processor cache
	   <li>Immutable classes - String,Integer,Long,etc ..
	   <li>Generics - Collections - List<T>,Map<K,V> - elimin CAST
	   <li>java.util.concurrency package
	   <ol>
	   <li>- Lock (ReeentrantLock, ReadWriteLock) - try finnaly
		<li> Semaphore, CountDownLatch
	   <li>- Executor (ThreadPool),Executors - eficienta folosirii threadurilor
	    <ul>
	      <li>Runnable
	      <li>Callable -> Futures
	    </ul>
	   </ol>
	   <br>
	   <b>Streams</b>
	   <li>Lambda expression
	   <li>Functional interface - Predicate,Consumer
	   <li>Stream processing
	     <ul>
	       <li>filter - s.filter(predicate) / s.filter((e) -> true/false)
	       <li>map - s.map(map funct) / s.map((e) -> g) => stream (g)
	     </ul>
	    <b>Arrays,Collections,Streams</b>
	    <ul>
	      <li>Filters
	      <li>Map
	      <li>Collectors - forEach,toCollection,
	        reduce
	        <li> parallelStream
	    </ul>
	    <br>
	    <b>IO</b>
	    <li>Files - File/ (nio) Path, Files - verify existence, create,delete
	    <li>InputStream/OutputStream - byte/byte array - TRY FINNALY
	    <li>Reader/Writer - io pe chars (byte to char encoding - UTF8)
	    <li>FileInputStream/FileOutputStream (file IO)
	    <li>FileReader,FileWriter
	    <li>InputStreamReader,OutputStreamWriter
	    <li>BufferedInputStream/BufferedOutputStream (flush)
	    <li>BufferedReader/BufferedWriter - readLine -> String
	    <li>DataInputStream/DataOuputStream - read write int,long,short,double,etc
	    <li>ObjectInputStream/ObjectOutputStream - Serializable!!!/Externalizable
	    <li>NIO - ByteChannels - ReadableByteChannel,WriteableByteChannel
	    <li>Networking - ServerSocket,Socket - server/client side of the TCP/IP connection
	      <ul>>
	        <li>Once we have an opened socket we can use getInputStream/getOutputStream on it
	      </ul>
	  <br>
	  <b>Design Patterns</b>
	  <i>Template de gandire si implementare</i>
	  <li>Factory pattern - static methods (private constructors)
	  <ul>
	    <li>DI acopera si factory si singleton pattern
	    <li>Exemplu - Integer.valueOf(String)-- CACHING/new Integer(String) - e NON CACHING
	  </ul>
	  <li>Singleton 
	  <li>DAO - Fiecare Obiect persistent are o clasa ajutatoare 
	  <li>Proxy - DI
	  <li>Decorator - DI
	  <li>MVC - Model View Controller
	  <ol>
	    <li>Se separa prezentarea de business logic 
	    <li>Controller - este responsabil cu modificarea datelor in urma actiunilor din view 
	    <li>Controller - este responsabil cu navigarea
	    <li>Controller - implementeaza constrangeri de business logic
	    <li>View - este responsabil cu afisarea si interactiunea cu userul
	  </ol>
	  <li>GOF (Gang of four) -lista de patterns
	  <br>
	  <b>SQL / JDBC/ Baze relationale</b>
	  <li>SQL == LIMBAJ GENERAL DE OPERARE PE BAZE RELATIONALE
	    <ul>
	      <li>UPDATE
	      <li>INSERT
	      <li>DELETE
	      <li>SELECT - JOINS, WHERE
	    </ul>
	  <li>BAZA RELATIONALA - MODELARE BAZATA PE TABELE (RELATII)
	  <ul>
	    <li>TRANZACTIONS - ACID 
	    <li>ATOMICITY + DURABILITY == Totul sau nimic
	    <li>CONSISTENCY + ISOLATION - ISOLATION LEVELS - READ UNCOMMITED, READ COMMITED,SERIALIZABLE
	    <li>Short transactions
	  </ul>
	  <li><B>JDBC -Java API Standard for SQL</B>
	    <ul>
	      <li>JDBC URL - jdbc:<dn>://urlbazadate - este recunoscut de driverul JDBC
	      <li>DriverManager - getConnection
	      <li>Connection - TRY FINALLY 
	        <ol>
	          <li>Use with try .. finally or try() .. (with resources/Java 7+)
	          <li> IS NOT THREAD SAFE !!!
	          <li> DataSource - Connection Pool - maxConnSize,maxIdleConnSize, ..
	             <ul>
	               <li>Se configureaza la nivel de container WEB/JEE - Tomcat,JBoss,Jetty
	               <li>Se obtine prin JNDI/DI
	                  - InitialContext.lookup , @Resource, @Inject
	             </ul>
	        </ol>
	        <li>Statement,PreparedStatement - created by Connection/ executeQuery ->ResultSet ,executeUpdate -> int,execute
	        <li>ResultSet - next() -> boolean (while (rs.next()) { ... rs.getString(1..)/..})
	        <li> ResultSet,Statement,PreparedStatement - finally { rs.close(),stmt.clse() ..}
	        <li> Putem cupla mai multe Statements in o singura tranzactie
	           <ol>
	             <li>conn.setAutocommit(false);
	             <li>s = conn.prepareStatement();
	             <li>s.execute...
	             <li>conn.commit()/ conn.rollback() // eventual in finally
	           </ol>
	    </ul>
	    <br>
	    <b>Exceptions</b>
	    <li>Checked exceptions - in semnatura si trebe interceptate cu catch daca nu te propag mai departe
	    <li>Unchecked exceptions - nu e necesar sa apara in semnatura metodelor
	    <li>Unchecked exceptions - extends Error, RuntimeException
	    <li>Checked exception - extends Exception
	    <li>Constructor (String pMsg),(String pMsg,Throwable pCause)
	    <li>Cuvinte cheie - throws - in semnatura metodei/ throw - arunca o exception, try, catch, finally
	    <li>Superclasa la TOATE tipurile de exceptii - Throwable
	    <li>O exceptie netratata/necapturata - omoara Thread-ul
	    <li> pot avea multiple catch statements
	      <code>
	        try {
	        } catch(E1 e1) {
	        } catch(E2 e2) {
	        ...
	        } finally {
	        }
	        
	      </code>
	      E1 NU trebe sa fie o superclasa a lui E2/ exceptiile se pun in catch de la cea mai specifica la cea mai generala
	    <br>
	    <B>HTTP - hyper text transfer protocol</B>
	    <li>E protocolul WEB
	    <li>Model <b>Request</b>/<b>Response</b> bazat pe Sockets
	    <li>Request attributes - <i>URL</i>,
	    <i>METHOD - GET,POST,PUT,DELETE,HEAD,TRACE,OPTIONS</i>,
	    <i>Headers : Accept:text/html...,Content-Type:application/json...,Accept-Language:ro</i>,
	    <i>query parameters - fie in URL http:.../..?p1=v1&p2=v2 fie in body-ul request</i>
	    <li>Response attributes - <i>Status - 2xx - OK,3xx - temp condition,4xx - App error,5xx - Server error</i>,
					<i>Headers : Content-Type:text/html...,Content-Encoding:xx,Content-Length:1355</i>,
					<i>Response body</i>
			<li>Cookies ... tot headers cu 'puteri' speciale - au 'expiration' time - in secunde, -1 == pana cand se inchide browserul
			  <ul>
			    <li>Ajuta serverul sa urmareasca clientii
			    <li>JSESSION_ID cookie - generat de Tomcat/Jetty/JBoss etc pentru Session tracking
			    
			  </ul>
				<br>
				<B>WEB API</B>	
				<li>Modeleaza in Java protocolul HTTP
				<li>HttServlet - doGet,doPost,doPut samd .. (service e catch all pentru toate metodele http)
				<li>HttpServletRequest - modeleaza request HTTP
				<li>HttpServletResponse - modeleaza response HTTP
				<li>doGet(HttpServletRequest,HttpServletResponse) ... 
				sunt apelate de servlet container (TOMCAT, etc)	cu o instanta de request si alta de response
				<li> request.getContextPath() - radacina aplicatiei ("banking")
				<li> request.getParameter("nume parametru")    
				<li> request.getHeader("nume header")
				<li> response.setHeader("nume header","Valoare header")
				<li> response.setStatus
				<li> response.addCookie,..
				<li> response.getWriter() -> scriu body-ul 
				<li> NAVIGAREA - client side navigation <a href=".."></a>/ Server side redirect - response.sendRedirect(newURL)
				<li> ORICE SERVLET E MAPAT PE UN URL PATTERN : /servlets/account/show;/sales/info/*
				<li> Maparea se face in web.xml - care se gaseste in directorul WEB-INF, SAU de la Java Servlet API 3.0+ cu @WebServlet("///")
				<li> JSP - Java server pages - Template language pentru generare content (response HTTP)
				<ul><li> orice JSP file -> compilat in servlet
				<li> JSP e mai comod pentru generare HTML (dar nu numai, vezi exemplu cu JSON)
				<li> JSP - <% %>, <%= %>, <%@ Page ... - directie
				<li> JSP a fost urmat de JSF - Java server faces - templating si mai destept
				</ul>
				<li><b>Security</b>
				  <ol>
				    <li>Authentication - who's who - User <- Credential
				      <ul>
				        <li>web.xml - security constraints
				        <li>authentication mode - form - user name, password
				        / realm - mecanismul de verificare parola per user
				        / realms are non standard  - exista si la jboss,tomcat, jetty, weblogic un database realm
				        / database realm - tabela useri (cu parole), tabela user-roluri
				        <li> request.getUserPrincipal() != null SUNT AUTENTIFICAT
				      </ul>
				    <li>Authorization - who's doing what - User <-> Roles
				      <ul>
				        <li>Tot realm-ul asociaza userii cu rolurile
				        <li>request.isUserInRole("rolName")
				        <li> In EJB, sau SpringSecurity @RolesAllowed("role")
				      </ul>
				    <li>Privacy/confidentiality - cryptography
				      <ul>
				        <li>https - SSL/TLS - Certificates
				        <li>Electronic signature
				      </ul>
				  </ol>
				<li><b>Packaging a web app - web archives - WAR</b>
				<pre>
				  -ROOT--
				         |META-INF
				         |   -- context.xml (tomcat only)
				         |
				         |
				         |WEB-INF
				           -- web.xml,
				           -- jboss-web.xml (jboss only)
				           -- beans.xml
				           --classes--|
				                      | (curs/banking/ws/AccountService.class)
				           -- lib --|
				                    | (jar-uri gen h2.jar,etc..)
				         | images --| (jpg-uri, etc)
				      - index.jsp
				      - main.css
				      - etc ..
				</pre>
				<br>
				<b> REST SERVICES</b>
				<li> REPRESENTATIONAL STATE TRANSFER - RESURSE + VERBE 
				<li> REST FUNCTIONEAZA PESTE HTTP
				<li> ACTIUNI (VERBE) IDEMPOTENTE - prin repetare (balbaire) NU se schimba rezultatul pe SERVER
				   <i>GET</i>,<i>DELETE</i>,<i>PUT</i>
				<li> VERBE NON IDEMPOTENTE - <i>POST</i>
				<li> Resources - /xx/accounts(customers;transactions;addresses;) - SUBSTANTIVE
				<li> Resursele se organizeaza pe arbori 
				<li> Resource collections -
				 <pre>
				   /xxx/accounts
				     -GET - returneaza List<Account>
				     -POST (Account) - adauga account la collection
				     -PUT /xxx/accounts/123 (Account) - actualizeaza account cu id=123
				     -DELETE /xxx/accounts/123 - sterge account 123
				     -GET /xxx/accounts/123 - returneaza account cu id 123
				 </pre>
				<br>
				<b>DEPENDENCY INJECTION - DI</b>
				<li>Inversion of control - don't call us, we call you
				<li>Este asigurat de un framework si API
				  <ol>
				    <li>CDI - Context dependency injection (API - @Inject,@Produces,@PostConstruct) - pentru JEE6/JEE7; implementare WELD
				    <li>Spring DI - alt api + framework - alte annotari
				    <li> Google Guice - alt api + framework
				    <li> Google DAGGER 1/DAGGER 2 - api + framework (generare statica de cod) 
				  </ol>
				<li> Type safety - cel mai bun contract pe tipul de date injectat
				<li> Lifecycle - Scopes - 
				  <ul>
				    <li>ApplicationScope - obiecte alive pe durata aplicatiei 
				    <li>SessionScope - obiecte alive pe durata sesiunii utilizator (HTTPSession)
				      - un set de obiecte pentru FIECARE SESSION
				     <li>RequestScope - obiecte alive pe durata unui request (cel mai scurt lifecycle)
				     <li>ConversatioScope - asta e intalnit la JSF de exemple 
				  </ul>
				 <li>Lifecycle - @PostConstruct, @PreDestroy
				   <pre>
				     class XXX {
				     @PostConstruct
				       void init() {
				       ..
				       }
				       
				       @PreDestroy
				       void destroy() {
				       }
				     }
				   
				     @Inject
				     XXX xx;
				     
				     -- se injecteaza instanta
				     -- xxx= new XXX() - o face DI framework
				     -- xxx.init() - o face DI framework
				     -- lifecycle - obiect alive
				     -- xxx.destroy() - o face DI framework
				     -- xxx este garbage collected
				   </pre>
				 <li> Injection types : <b>Field</b>,<b>Method</b>,<b>Constructor</b>
				 <pre>
				  @SessionScope
				  class XXX {
				    
				  }
				 
				  @SessionScope
				  class Pufi1 {
				 
				 	   @Inject
				 	   //@Named("x")
				 	   private XXX xxx; // Field injection
				 	   @Inject
				 	   //@Named("y")
				 	   private XXX zzz;
				 	 }
				 	 
				 	 // For method injection
				 	 @SessionScope
				 	 class Pufi2 {
				 	   private XXX yyy;
				 	 
				 	   @Inject
				 	   void puneXXXValue(XXX pXXX) {
				 	     yyy = pXXX;
				 	     ... logging
				 	   }
				 	 }
				 	 
				 	 //For constructor injection
				 	 @RequestScope
				 	 class Pufi3 {
				 	   private XXX yyy;
				 	 
				 	   @Inject
				 	   Pufi3(XXX pXXX) {
				 	     yyy = pXXX;
				 	     ... logging
				 	   }
				 	 }
				 </pre>
				 <li>Injection mechanism
				   <ul>
				     <li>new XXX() + injectie / new XXX(Injected params) + injectie (@PostConstruct)
				     <li>foloseste Producers 
				       <pre>
				        @ApplicationScope
				        class MyProducerDeXXX {
				       
				         @Produces
				         XXX createMyInstanceDeXXX() {
				           XXX xxx = new XXX(33);
				           xxx.setAia();
				           xxx.setAilalata();
				           return xxx;
				         }
				        }
				       </pre>
				   </ul>
				<br>
				<b>JPA - Java persistence API</b>
				<li>SQL - JAVA impedance mismatch
				<li>ORM - Object relational mapping - Modul declarativ (JDBC imperativ)de interactie obiecte Java cu SQL Databases
				<li>ORM implementation - countless !!!!
				 <ul>
				   <li>Hibernate
				   <li>Eclipse Link
				   <li>Batik, iBatis
				   <li> JPA - standard API 2.1, parte din JEE6/7
				    - JPA is the API, dar frameworkul este Hibernate,Eclipse-Link
				 </ul>
				 <li>JPA - Entities, Entity managers
				 <li>Entities - java POJO cu adnotari - mapare clasa pe tabele, 
				   mapping campuri pe coloane in tabele, 
				   mapping object relations to table relation
				   mapping entity relations - @OneToOne,
				     @OneToMany, @ManyToOne, @ManyToMany
				 <li>EntityManager 
				   - manage entity lifecycle , caching, transactions
				   - has close method as the Connection !!!!
				   <ul>
				     <li> persist - creeaza o noua inregistrare pentru o entitate noua - INSERT
				     <li> delete - sterge inregistrarea pentru o entitate
				     <li> merge - modifica un obiect incarcat din baza sql cu datele din referinta folosita ca parametru la metoda
				     <li> query - JPQL ('object oriented' SQL)
				     <li> transaction management -
				         em.getTransaction() - Transaction - begin,commit,rollback 
				   </ul>
				 <li>Query Language - JPQL - NU E SQL DAR SEAMANA TARE
				 <li>Hibernate notices - 
				   <ul>
				    <li> same annotations + some extra annotation
				    <li> Session instead EntityManager
				   </ul>
				 <li> Entities lifecycle 
				   NEW, MANAGED, DETACHED
				   NEW -> MANAGED - via persist
				   -> MANAGED - via find, query, ...
				   MANAGED -> DETACHED - via flush, commit,close
				   DETACHED -> MANAGED - merge
		<br>
		<b>Maven, Gradle</b>
		<li>E un build management system / scris in java
		<li> pom.xml - fisierul care descrie procesul de build
		<li> in pom avem partea de dependency
		<li> plugins - mecanismul extensibil de build sepcializat
		  <ul>
		    <li>Compilare</li>
		    <li>Jar</li>
		    <li>War</li>
		    <li>Testing</li>
		    <li>sql-maven-plugin - folosit de noi in testing</li>
		    <li>Plugin pentru tomcat</li>
		    <li>Plugin pentru JBoss</li>
		  </ul>
		<li>sub module - dependenta intre submodule/
		  simpleweb -> simplebusiness -> simpledao -> simplemodel
		<br>
		<b>Source control - GIT</b>
		<li>Management surse - cu versiuni, branching si merging
		<li>git checkout - trage o copie locala a repositoriului central
		<li>git add - adauga fisiere noi la index  (fisiere modificate)
		<li>git commit - salveaza intr-o noua versiune ce s-a modificat de la ultimit checkout/commit
		<li>git pull - actualizeaza repositoriul local cu ce s-a mai facut pe server
		<li>git push - arunca pe repository-ul central modificarile comise local
		<li>git merge
	</div>
</body>
</html> 